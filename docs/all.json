{"shell":true,"revision":"535ea818fac24be7ed81865a49310a3de360ee61","objects":[{"type":null,"source":"lib/filtrex.ex:2","object_type":"ModuleObject","moduledoc":"Filtrex consists of three primary components:\n\n  * `Filtrex` - handles the overall parsing of filters and delegates to\n    `Filtrex.AST` to build an ecto query expression\n\n  * `Filtrex.Condition` - an abstract module built to delegate to specific condition modules in the format of `Filtrex.Condition.Type` where the type is converted to CamelCase (See `Filtrex.Condition.Text.parse/2`)\n\n  * `Filtrex.Fragment` - simple struct to hold generated expressions and values to be used when generating queries for ecto\n","module":"Elixir.Filtrex","id":"Filtrex"},{"type":null,"source":"lib/filtrex/ast.ex:2","object_type":"ModuleObject","moduledoc":"`Filtrex.AST` is a helper for building out the ecto macro query expression\nfrom a set of conditions. Typically, it shouldn't need to be called direcly.\n","module":"Elixir.Filtrex.AST","id":"Filtrex.AST"},{"type":null,"source":"lib/filtrex/condition.ex:2","object_type":"ModuleObject","moduledoc":"`Filtrex.Condition` is an abstract module for parsing conditions.\nTo implement your own condition, add `use Filtrex.Condition` in your module and implement the three callbacks:\n\n  * `parse/2` - produce a condition struct from a configuration and attributes\n  * `type/0` - the description of the condition that must match the underscore version of the module's last namespace\n  * `comparators/0` - the list of used query comparators for parsing params\n","module":"Elixir.Filtrex.Condition","id":"Filtrex.Condition"},{"type":null,"source":"lib/filtrex/conditions/boolean.ex:5","object_type":"ModuleObject","moduledoc":"`Filtrex.Condition.Boolean` is a specific ondition type for handling boolean flags. It allows an empty string for false value as well as string representations \"true\" and \"false\". Its comparators only consist of \"is\" or \"is not\".\n","module":"Elixir.Filtrex.Condition.Boolean","id":"Filtrex.Condition.Boolean"},{"type":null,"source":"lib/filtrex/conditions/date.ex:13","object_type":"ModuleObject","moduledoc":"`Filtrex.Condition.Date` is a specific condition type for handling date filters with various comparisons.\n\nThere are three different value formats allowed listed in each of the three tables below\n\n| Key        | Type    | Format / Allowed Values                   |\n|------------|---------|-------------------------------------------|\n| inverse    | boolean | See `Filtrex.Condition.Text`              |\n| column     | string  | any allowed keys from passed `config`     |\n| comparator | string  | after, on or after, before, on or before,|\n|            |         | is, is not, equals, does not equal        |\n| value      | string  | \"YYYY-MM-DD\"                              |\n| type       | string  | \"date\"                                    |\n\n| Key        | Type    | Format / Allowed Values                   |\n|------------|---------|-------------------------------------------|\n| inverse    | boolean | See `Filtrex.Condition.Text`              |\n| column     | string  | any allowed keys from passed `config`     |\n| comparator | string  | between, not between                      |\n| value      | map     | %{start: \"YYYY-MM-DD\", end: \"YYYY-MM-DD\"} |\n| type       | string  | \"date\"                                    |\n\n| Key        | Type    | Format / Allowed Values                                       |\n|------------|---------|---------------------------------------------------------------|\n| inverse    | boolean | See `Filtrex.Condition.Text`                                  |\n| column     | string  | any allowed keys from passed `config`                         |\n| comparator | string  | in the last, not in the last,                                |\n|            |         | in the next, not in the next                                  |\n| value      | string  | %{interval: (days, weeks, months, or years), amount: integer} |\n| type       | string  | \"date\"                                                        |\n","module":"Elixir.Filtrex.Condition.Date","id":"Filtrex.Condition.Date"},{"type":null,"source":"lib/filtrex/conditions/text.ex:6","object_type":"ModuleObject","moduledoc":"`Filtrex.Condition.Text` is a specific condition type for handling text filters with various comparisons.\n\nIt accepts the following format (where `inverse` is passed directly from `Filtrex.Condition`):\n```\n%{\n  inverse: boolean,\n  column: string,\n  comparator: string,  # equals, is, is not, contains, does not contain\n  value: string,\n  type: \"text\"\n}\n```\n","module":"Elixir.Filtrex.Condition.Text","id":"Filtrex.Condition.Text"},{"type":"protocol","source":"lib/filtrex/encoder.ex:2","object_type":"ModuleObject","moduledoc":"Encodes a condition into `Filtrex.Fragment` as an expression with values.\nImplementing this protocol is required for any new conditions.\nSee `Filtrex.Utils.Encoder` for helper methods with this implementation.\n\nExample:\n```\ndefimpl Filtrex.Encoder, for: Filtrex.Condition.Text do\n  def encode(%Filtrex.Condition.Text{column: column, comparator: \"is\", value: value}) do\n    %Filtrex.Fragment{expression: \"#{column} = ?\", values: [value]}\n  end\nend\n```\n","module":"Elixir.Filtrex.Encoder","id":"Filtrex.Encoder"},{"type":"impl","source":"lib/filtrex/conditions/boolean.ex:42","object_type":"ModuleObject","moduledoc":null,"module":"Elixir.Filtrex.Encoder.Filtrex.Condition.Boolean","id":"Filtrex.Encoder.Filtrex.Condition.Boolean"},{"type":"impl","source":"lib/filtrex/conditions/date.ex:84","object_type":"ModuleObject","moduledoc":null,"module":"Elixir.Filtrex.Encoder.Filtrex.Condition.Date","id":"Filtrex.Encoder.Filtrex.Condition.Date"},{"type":"impl","source":"lib/filtrex/conditions/text.ex:50","object_type":"ModuleObject","moduledoc":null,"module":"Elixir.Filtrex.Encoder.Filtrex.Condition.Text","id":"Filtrex.Encoder.Filtrex.Condition.Text"},{"type":null,"source":"lib/filtrex/fragment.ex:2","object_type":"ModuleObject","moduledoc":"`Filtrex.Fragment` is a simple struct used to hold an `expression` and `values`.\nIt is used by `Filtrex.Encoder.encode/1` to turn conditions into ecto queries.\nExample:\n```\n%Filtrex.Fragment{expression: \"(text = ?)\", values: [\"Buy Milk\"]}\n```\n","module":"Elixir.Filtrex.Fragment","id":"Filtrex.Fragment"},{"type":null,"source":"lib/filtrex/params.ex:2","object_type":"ModuleObject","moduledoc":"`Filtrex.Params` is a module that parses parameters similar to Phoenix, such as:\n\n```\n%{\"due_date_between\" => %{\"start\" => \"2016-03-10\", \"end\" => \"2016-03-20\"}, \"text_column\" => \"Buy milk\"}\n```\n","module":"Elixir.Filtrex.Params","id":"Filtrex.Params"},{"type":null,"source":"lib/filtrex/utils/encoder.ex:2","object_type":"ModuleObject","moduledoc":"Helper methods for implementing the `Filtrex.Encoder` protocol.\n","module":"Elixir.Filtrex.Utils.Encoder","id":"Filtrex.Utils.Encoder"},{"type":"def","source":"lib/filtrex.ex:17","signature":[["config",[],null],["arg2",[],"Elixir"]],"object_type":"FunctionObject","name":"parse","module_id":"Filtrex","id":"parse/2","doc":"Parses a filter expression and returns errors or the parsed filter with\nthe appropriate parsed sub-structures.\n\nThe `config` option is a map of the acceptable types and the configuration\noptions to pass to each condition type.\nExample:\n```\n%{\n  text: %{keys: ~w(title comments)}\n}\n```\n","arity":2},{"type":"def","source":"lib/filtrex.ex:77","signature":[["config",[],null],["params",[],null]],"object_type":"FunctionObject","name":"parse_params","module_id":"Filtrex","id":"parse_params/2","doc":"This function converts Plug-decoded params like the example below into a filtrex struct based on options in the config. This config is the same as passed into `parse/2` for a map structure.\n```\n%{\"comments_contains\" => \"love\",\n  \"title\" => \"My Blog Post\",\n  \"created_at_between\" => %{\"start\" => \"2014-01-01\", \"end\" => \"2016-01-01\"}}\n```\n","arity":2},{"type":"defmacro","source":"lib/filtrex.ex:94","signature":[["filter",[],null],["model",[],null]],"object_type":"FunctionObject","name":"query","module_id":"Filtrex","id":"query/2","doc":"Converts a filter with the specified ecto module name into a valid ecto query\nexpression that is compiled when called.\n","arity":2},{"type":"def","source":"lib/filtrex/ast.ex:7","signature":[["filter",[],null],["model",[],null]],"object_type":"FunctionObject","name":"build_query","module_id":"Filtrex.AST","id":"build_query/2","doc":"Builds a 'from' ecto query from conditions and a join operator (e.g. 'AND')","arity":2},{"type":"def","source":"lib/filtrex/condition.ex:56","signature":[["config",[],null],["key_with_comparator",[],null]],"object_type":"FunctionObject","name":"param_key_type","module_id":"Filtrex.Condition","id":"param_key_type/2","doc":"Parses a params key into the condition type, column, and comparator","arity":2},{"type":"def","source":"lib/filtrex/condition.ex:28","signature":[["config",[],null],["map",[],"Elixir"]],"object_type":"FunctionObject","name":"parse","module_id":"Filtrex.Condition","id":"parse/2","doc":"Parses a condition by dynamically delegating to modules\n\nIt delegates based on the type field of the options map (e.g. `Filtrex.Condition.Text` for the type `\"text\"`).\nExample Input:\nconfig:\n```\nFiltrex.Condition.parse(%{\n  text: %{keys: ~w(title comments)}  # passed to the specific condition\n}, %{\n  type: string,                      # converted to Filtrex.Condition.\"__\" dynamically\n  column: string,\n  comparator: string,\n  value: string,\n  inverse: boolean                   # inverts the comparator logic\n})\n```\n","arity":2},{"type":"def","source":"lib/filtrex/condition.ex:85","signature":[["value",[],null],["type",[],null],["filter_type",[],null]],"object_type":"FunctionObject","name":"parse_error","module_id":"Filtrex.Condition","id":"parse_error/3","doc":"Generates an error description for a generic parse error","arity":3},{"type":"def","source":"lib/filtrex/condition.ex:91","signature":[["column",[],null],["filter_type",[],null]],"object_type":"FunctionObject","name":"parse_value_type_error","module_id":"Filtrex.Condition","id":"parse_value_type_error/2","doc":"Generates an error description for a parse error resulting from an invalid value type","arity":2},{"type":"def","source":"lib/filtrex/condition.ex:69","signature":[["value",[],null],["list",[],null]],"object_type":"FunctionObject","name":"validate_in","module_id":"Filtrex.Condition","id":"validate_in/2","doc":"Helper method to validate whether a value is in a list","arity":2},{"type":"def","source":"lib/filtrex/condition.ex:80","signature":[["value",[],null]],"object_type":"FunctionObject","name":"validate_is_binary","module_id":"Filtrex.Condition","id":"validate_is_binary/1","doc":"Helper method to validate whether a value is a binary","arity":1},{"type":"def","source":"lib/filtrex/conditions/boolean.ex:11","signature":[],"object_type":"FunctionObject","name":"comparators","module_id":"Filtrex.Condition.Boolean","id":"comparators/0","doc":false,"arity":0},{"type":"def","source":"lib/filtrex/conditions/boolean.ex:13","signature":[["config",[],null],["map",[],"Elixir"]],"object_type":"FunctionObject","name":"parse","module_id":"Filtrex.Condition.Boolean","id":"parse/2","doc":false,"arity":2},{"type":"def","source":"lib/filtrex/conditions/boolean.ex:9","signature":[],"object_type":"FunctionObject","name":"type","module_id":"Filtrex.Condition.Boolean","id":"type/0","doc":false,"arity":0},{"type":"def","source":"lib/filtrex/conditions/date.ex:47","signature":[],"object_type":"FunctionObject","name":"comparators","module_id":"Filtrex.Condition.Date","id":"comparators/0","doc":false,"arity":0},{"type":"def","source":"lib/filtrex/conditions/date.ex:49","signature":[["config",[],null],["map",[],"Elixir"]],"object_type":"FunctionObject","name":"parse","module_id":"Filtrex.Condition.Date","id":"parse/2","doc":false,"arity":2},{"type":"def","source":"lib/filtrex/conditions/date.ex:45","signature":[],"object_type":"FunctionObject","name":"type","module_id":"Filtrex.Condition.Date","id":"type/0","doc":false,"arity":0},{"type":"def","source":"lib/filtrex/conditions/text.ex:23","signature":[],"object_type":"FunctionObject","name":"comparators","module_id":"Filtrex.Condition.Text","id":"comparators/0","doc":false,"arity":0},{"type":"def","source":"lib/filtrex/conditions/text.ex:25","signature":[["config",[],null],["map",[],"Elixir"]],"object_type":"FunctionObject","name":"parse","module_id":"Filtrex.Condition.Text","id":"parse/2","doc":"Tries to create a valid text condition struct, calling helper methods\nfrom `Filtrex.Condition` to validate each type. If any of the types are not valid,\nit accumulates the errors and returns them.\n","arity":2},{"type":"def","source":"lib/filtrex/conditions/text.ex:21","signature":[],"object_type":"FunctionObject","name":"type","module_id":"Filtrex.Condition.Text","id":"type/0","doc":false,"arity":0},{"type":"def","source":"lib/filtrex/encoder.ex:1","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__protocol__","module_id":"Filtrex.Encoder","id":"__protocol__/1","doc":false,"arity":1},{"type":"def","source":"lib/filtrex/encoder.ex:17","signature":[["condition",[],null]],"object_type":"FunctionObject","name":"encode","module_id":"Filtrex.Encoder","id":"encode/1","doc":"The function that performs the encoding","arity":1},{"type":"def","source":"lib/filtrex/conditions/boolean.ex:42","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__impl__","module_id":"Filtrex.Encoder.Filtrex.Condition.Boolean","id":"__impl__/1","doc":false,"arity":1},{"type":"def","source":"lib/filtrex/conditions/boolean.ex:43","signature":[["map",[],"Elixir"]],"object_type":"FunctionObject","name":"encode","module_id":"Filtrex.Encoder.Filtrex.Condition.Boolean","id":"encode/1","doc":false,"arity":1},{"type":"def","source":"lib/filtrex/conditions/date.ex:84","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__impl__","module_id":"Filtrex.Encoder.Filtrex.Condition.Date","id":"__impl__/1","doc":false,"arity":1},{"type":"def","source":"lib/filtrex/conditions/date.ex:85","signature":[["map",[],"Elixir"]],"object_type":"FunctionObject","name":"encode","module_id":"Filtrex.Encoder.Filtrex.Condition.Date","id":"encode/1","doc":false,"arity":1},{"type":"def","source":"lib/filtrex/conditions/text.ex:50","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__impl__","module_id":"Filtrex.Encoder.Filtrex.Condition.Text","id":"__impl__/1","doc":false,"arity":1},{"type":"def","source":"lib/filtrex/conditions/text.ex:51","signature":[["map",[],"Elixir"]],"object_type":"FunctionObject","name":"encode","module_id":"Filtrex.Encoder.Filtrex.Condition.Text","id":"encode/1","doc":false,"arity":1},{"type":"def","source":"lib/filtrex/params.ex:10","signature":[["config",[],null],["params",[],null]],"object_type":"FunctionObject","name":"parse_conditions","module_id":"Filtrex.Params","id":"parse_conditions/2","doc":"Converts parameters to a list of conditions","arity":2},{"type":"defmacro","source":"lib/filtrex/utils/encoder.ex:6","signature":[["comparator",[],null],["reverse_comparator",[],null],["expression",[],null],["\\\\",[],[["values_function",[],null],["{}",[["line",21]],["&",[],[[["{}",[["line",21]],["&",[],[1]]]]]]]]]],"object_type":"FunctionObject","name":"encoder","module_id":"Filtrex.Utils.Encoder","id":"encoder/4","doc":"This macro allows a simple creation of encoders using a simple DSL.\n\nExample:\n```\nencoder \"is\", \"is not\", \"column = ?\", &(&1)\n```\n\nIn this example, a comparator and its reverse are passed in followed\nby an expression where \"column\" is substituted for the actual column\nname from the struct. The final argument is a function (which is not\nnecessary in this case since it is the default value) that takes the\nraw value being passed in and returns the transformed value to be\ninjected as a value into the fragment expression.\n","arity":4}],"language":"elixir","git_repo_url":"https://github.com/rcdilorenzo/filtrex.git","client_version":"0.4.0","client_name":"inch_ex","branch_name":"master","args":[]}